package br.com.bot.cyberseguranca.service;

import br.com.bot.cyberseguranca.exception.PersistenceException;
import br.com.bot.cyberseguranca.model.AlertaSeguranca;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Service
public class VulnerabilityService {

    private final ObjectMapper mapper;
    private final String filePath;

    public VulnerabilityService(ObjectMapper mapper,
                                @Value("${vulnerability.file.path:}") String configuredPath) {
        this.mapper = mapper;
        this.filePath = (configuredPath != null && !configuredPath.isBlank())
                ? configuredPath
                : System.getProperty("user.dir") + File.separator + "data" + File.separator + "vulnerabilidades.json";
    }

    /** Exposto para testes (idempot√™ncia e integridade do JSON). */
    public String getFilePath() {
        return filePath;
    }

    public List<AlertaSeguranca> listarVulnerabilidades() {
        try {
            File file = new File(filePath);
            System.out.println("üîç [AUDITORIA] Acessando base de dados em: " + file.getAbsolutePath());

            if (!file.exists()) {
                System.out.println("‚ö†Ô∏è [AVISO] Arquivo n√£o encontrado em: " + filePath);
                return List.of();
            }

            List<AlertaSeguranca> resultado = mapper.readValue(file, new TypeReference<List<AlertaSeguranca>>() {});
            System.out.println("‚úÖ [SUCESSO] Leitura conclu√≠da. Itens carregados: " + resultado.size());
            return resultado;

        } catch (IOException e) {
            System.err.println("‚ùå [ERRO CR√çTICO] Falha na integridade do arquivo JSON!");
            throw new PersistenceException("Erro t√©cnico ao ler a base de dados GRC (JSON)", e);
        }
    }

    /**
     * Adiciona uma nova vulnerabilidade e persiste no arquivo f√≠sico.
     * Idempotente: se o id j√° existir, n√£o duplica e apenas loga.
     * Thread-safe para uso com parallelStream (varredura das 15 fontes).
     */
    public void adicionarVulnerabilidade(AlertaSeguranca nova) {
        synchronized (this) {
            try {
                List<AlertaSeguranca> atuais = new ArrayList<>(listarVulnerabilidades());
                boolean jaExiste = atuais.stream().anyMatch(v -> v.id().equals(nova.id()));
                if (jaExiste) {
                    System.out.println("üìã [IDEMPOT√äNCIA] Registro j√° existente em vulnerabilidades.json: " + nova.id());
                    return;
                }
                atuais.add(nova);
                File file = new File(filePath);
                File parent = file.getParentFile();
                if (parent != null && !parent.exists()) {
                    parent.mkdirs();
                }
                mapper.writerWithDefaultPrettyPrinter().writeValue(file, atuais);
                System.out.println("üíæ [PERSIST√äNCIA] Novo registro GRC salvo com sucesso: " + nova.id());
            } catch (IOException e) {
                System.err.println("‚ùå [ERRO DE ESCRITA] N√£o foi poss√≠vel salvar no JSON!");
                throw new PersistenceException("Falha ao gravar registro de auditoria no sistema", e);
            }
        }
    }

    /** Verifica se j√° existe um registro com o id (para testes). */
    public boolean existePorId(String id) {
        return listarVulnerabilidades().stream().anyMatch(v -> v.id().equals(id));
    }
}