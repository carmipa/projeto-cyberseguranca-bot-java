package br.com.bot.cyberseguranca.service;

import br.com.bot.cyberseguranca.model.AlertaSeguranca;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * 1. Teste de Idempotência e Persistência
 * 2. Validação de integridade do vulnerabilidades.json
 * 3. Teste de concorrência (parallelStream / múltiplas threads).
 */
class VulnerabilityServiceTest {

    private ObjectMapper mapper;
    private String filePath;

    @BeforeEach
    void setUp(@TempDir Path tempDir) {
        mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        filePath = tempDir.resolve("vulnerabilidades.json").toAbsolutePath().toString();
    }

    private VulnerabilityService createService() {
        return new VulnerabilityService(mapper, filePath);
    }

    @Test
    @DisplayName("Idempotência: adicionar o mesmo id duas vezes não duplica e mantém JSON válido")
    void idempotencia_nao_duplica_registros() {
        VulnerabilityService service = createService();
        AlertaSeguranca alerta = new AlertaSeguranca(
                "CVE-2024-1234",
                "Teste",
                "HIGH",
                "NEW",
                LocalDateTime.now(),
                "Desc"
        );

        service.adicionarVulnerabilidade(alerta);
        service.adicionarVulnerabilidade(alerta);

        List<AlertaSeguranca> lista = service.listarVulnerabilidades();
        assertThat(lista).hasSize(1);
        assertThat(lista.get(0).id()).isEqualTo("CVE-2024-1234");
    }

    @Test
    @DisplayName("Persistência: arquivo vulnerabilidades.json é atualizado sem corromper JSON")
    void persistencia_json_valido() throws Exception {
        VulnerabilityService service = createService();
        AlertaSeguranca a1 = new AlertaSeguranca("ID-1", "T1", "LOW", "NEW", LocalDateTime.now(), "D1");
        AlertaSeguranca a2 = new AlertaSeguranca("ID-2", "T2", "HIGH", "NEW", LocalDateTime.now(), "D2");

        service.adicionarVulnerabilidade(a1);
        service.adicionarVulnerabilidade(a2);

        List<AlertaSeguranca> lidos = service.listarVulnerabilidades();
        assertThat(lidos).hasSize(2);

        // Releitura do arquivo cru para garantir que o JSON está íntegro
        List<AlertaSeguranca> recarregado = mapper.readValue(new File(filePath),
                new com.fasterxml.jackson.core.type.TypeReference<List<AlertaSeguranca>>() {});
        assertThat(recarregado).hasSize(2);
        assertThat(recarregado).extracting(AlertaSeguranca::id).containsExactlyInAnyOrder("ID-1", "ID-2");
    }

    @Test
    @DisplayName("Concorrência: múltiplas threads adicionando não corrompem o arquivo")
    void concorrencia_parallel_stream_sem_corromper_json() throws InterruptedException {
        VulnerabilityService service = createService();
        int numThreads = 10;
        int addsPerThread = 5;
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        CountDownLatch start = new CountDownLatch(1);
        CountDownLatch done = new CountDownLatch(numThreads);
        AtomicInteger idGen = new AtomicInteger(0);

        for (int t = 0; t < numThreads; t++) {
            executor.submit(() -> {
                try {
                    start.await();
                    for (int i = 0; i < addsPerThread; i++) {
                        int id = idGen.incrementAndGet();
                        service.adicionarVulnerabilidade(new AlertaSeguranca(
                                "CONC-" + id,
                                "T " + id,
                                "MEDIUM",
                                "NEW",
                                LocalDateTime.now(),
                                "D " + id
                        ));
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    done.countDown();
                }
            });
        }
        start.countDown();
        done.await();
        executor.shutdown();

        List<AlertaSeguranca> lista = service.listarVulnerabilidades();
        assertThat(lista).hasSize(numThreads * addsPerThread);
        assertThat(lista).extracting(AlertaSeguranca::id).doesNotHaveDuplicates();
    }

    @Test
    @DisplayName("existePorId retorna true quando o registro existe")
    void existePorId_retorna_true_quando_existe() {
        VulnerabilityService service = createService();
        service.adicionarVulnerabilidade(new AlertaSeguranca("X", "T", "LOW", "NEW", LocalDateTime.now(), "D"));
        assertThat(service.existePorId("X")).isTrue();
        assertThat(service.existePorId("Y")).isFalse();
    }
}
